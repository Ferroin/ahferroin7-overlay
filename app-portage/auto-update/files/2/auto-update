#!/usr/bin/env python3
#vi: set sw=4 :
# auto-update: an automatic updater for Gentoo
# Copyright (C) 2013  Austin S. Hemmelgarn
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

import subprocess
import smtplib

def main() {
    import argparse
    parser = argparse.ArgumentParser('Automated updates for gentoo.')
    parser.add_argument('-c', '--config', default='/etc/auto-update.conf',
    help='Specify an alternate configuration file to use.',
    target='config')
    args = parser.parse_args()
    del argparse
    del parser
    import configparser
    from socket import getfqdn
    config = configparser.ConfigParser()
    config.read(args.config)
    MAILSERVER=config['mail']['server']
    MAILUSER=config['mail']['user']
    MAILPASS=config['mail']['pass']
    DESTADDR=config['mail']['destination']
    FROMADDR='auto-update@' + getfqdn()
    SYNC=config.getBoolean('gentoo', 'sync') | False
    EIX=config.getBoolean('gentoo', 'eix') | False
    DEPCLEAN=config.getBoolean('gentoo', 'depclean') | True
    ECLEAN=config.getBoolean('gentoo', 'eclean') | False
    KERNCHECK=config.getBoolean('gentoo', 'kernel_check') | False
    KPKG=config['gentoo']['kernel_package']
    PYTHONUPDATE=config.getBoolean('gentoo', 'python_update') | True
    PERLCLEAN=config.getBoolean('gentoo', 'perl_clean') | True
    REVDEPREBUILD=config.getBoolean('gentoo', 'revdep_rebuild') | True
    PRESERVEDREBUILD=config.getBoolean('gentoo', 'preserved_rebuild') | True
    del configparser
    del config
    del getfqdn
    del args

    if MAILSERVER == None:
        MAILSERVER = 'localhost'

    if DESTADDR == None:
        DESTADDR = 'root@localhost'

    msg = 'From: ' + FROMADDR +'\r\n'
    msg += 'To: ' + DESTADDR + '\r\n'
    extra_msg = ''
    null = open('/dev/null', 'r+b')

    def send_message(msg):
        server = smtplib.SMTP()
        server.connect(MAILSERVER)
        if MAILUSER and MAILPASS:
            server.login(MAILUSER, MAILPASS)
        server.sendmail(msg)
        server.quit()
        return True

    if SYNC:
        try:
            sync_output = subprocess.check_output('emerge', '--sync',
                          stderr=subprocess.STDOUT, universal_newline=True)
        except subprocess.CalledProcessError:
            msg += 'Subject: Update Failed\r\n\r\n'
            msg += 'Update failed while running `emerge --sync`\r\n'
            msg += 'Command output:\r\n' + sync_output.replace('\n', '\r\n')
            send_message(msg)
            return 1

    if EIX:
        subprocess.call('eix-update', stdout=null, stderr=null)

    # Use equery to determine the current portage ebuild, and the newest
    # installable (non-masked) portage ebuild
    current_portage = subprocess.check_output('equery', '--quiet', '--no-color',
                      'list', '--format=$cpv', 'portage', universal_newlines=True)
    current_portage = subprocess.check_output('equery', 'which',
                      '=' + current_portage, universal_newlines=True)
    max_portage = subprocess.check_output('equery', 'which', 'portage',
                  universal_newlines=True)

    # If the ebuild paths don't match, then we need to update portage
    if max_portage != current_portage:
        portage_update = True
        try:
            portupdate = subprocess.check_output('emerge', '--oneshot', 'portage',
                         stderr=subprocess.STDOUT, universal_newlines=True)
        except subprocess.CalledProcessError:
            msg += 'Subject: Automatic Update Failed\r\n\r\n'
            msg += 'Update failed while running `emerge --oneshot portage`\r\n'
            msg += 'Command output:\r\n' + portupdate.replace('\n', '\r\n')
            send_message(msg)
            return 1
    else:
        portage_update = False

    pyversions = subprocess.check_output('equery', '-q', '-C', 'list',
                 '--format=$cpv', 'dev-lang/python', 'dev-java/jython',
                 'dev-python/pypy', 'dev-python/pypy-bin').splitlines()

    perlversion = subprocess.check_output('perl', '--version')

    try:
        update = subprocess.check_output('emerge', '--update', '--deep',
                 '--with-bdeps=y', '--newuse', 'world', stderr=subprocess.STDOUT,
                 universal_newline=True)
    except subprocess.CalledProcessError:
        msg += 'Subject: Automatic Update Failed\r\n\r\n'
        msg += 'Update failed while running `emerge --update --deep --with-bdeps=y --newuse world\r\n'
        msg += 'Command output:\r\n' + update.replace('\n', '\r\n')
        send_message(msg)
        return 1

    if PRESERVEDREBUILD:
        try:
            update = subprocess.check_output('emerge', '--oneshot', '@preserved-rebuild',
                     stderr=subprocess.STDOUT, universal_newline=True)
        except subprocess.CalledProcessError:
            extra_msg += 'Running `emerge --oneshot @preserved-rebuild` failed.\r\n'
            extra_msg += 'You should almost certaily rerun it manually.\r\n\r\n'

    newpyversions = subprocess.check_output('equery', '-q', '-C', 'list',
                    '--format=$cpv', 'dev-lang/python', 'dev-java/jython',
                    'dev-python/pypy', 'dev-python/pypy-bin').splitlines()
    if pyversions != newpyversions:
        if PYTHONUPDATE:
            try:
                subprocess.call('python-updater', stdout=null, stderr=null)
            except subprocess.CalledProcessError:
                extra_msg += 'Running python-updater failed, it needs to be rerun manually.\r\n\r\n'
        else:
            extra_msg += 'Python has been updated, you should probably run python-updater.\r\n\r\n'

    newperlversion = subprocess.check_output('perl', '--version')
    if perlversion != newperlversion:
        if PERLCLEAN:
            try:
                subprocess.call('perl-cleaner', '--all', stdout=null, stderr=null)
            except subprocess.CalledProcessError:
                extra_msg += 'Running perl-cleaner failed, it needs to be rerun manually.\r\n\r\n'
        else:
            extra_msg += 'Perl has been updated, you need to run perl-cleaner.\r\n\r\n'

    if DEPCLEAN:
        subprocess.call('emerge', '--depclean', stdout=null, stderr=null)

    if REVDEPREBUILD:
        subprocess.call('revdep-rebuild', stdout=null, stderr=null)

    if ECLEAN:
        subprocess.call('eclean -dv packages', stdout=null, stderr=null)
        subprocess.call('eclean -dv distfiles', stdout=null, stderr=null)

    subprocess.call('etc-update', '-p')

    msg += 'Subject: Automatic Update Successful\r\n\r\n'

    confupdate = subprocess.check_output('ls', '-R', '/etc')
    confupdate = subprocess.check_output('grep', '-c', '._cfg', confupdate)

    msg += confupdate + ' config files need to be manually merged.\r\n\r\n'

    if KERNCHECK:
        kversion_current = subprocess.check_output('uname', '-v').partition('-')[0]
        kversion_source = subprocess.check_output('equery', '-q', '-C', 'list',
                          '--format=$fullversion', KPKG)
        if kversion_current != kversion_source:
            msg += 'Kernel sources have been updated, kernel rebuild required.\r\n'
            msg += 'Don\'t forget to update any out of tree modules as well.\r\n'

    msg += extra_msg
    send_message(msg)
    return 0

if __name__ == '__main__':
    exit(main())
